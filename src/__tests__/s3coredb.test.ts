import { S3CoreDB } from '../s3CoreDB';
import { DataItem, SecurityContext } from '../types';
import { S3Client } from '../s3Client';

// Mock S3Client
const mockData: { [key: string]: string } = {};

const mockS3Client = {
  putObject: jest.fn().mockImplementation((key: string, data: any) => {
    mockData[key] = JSON.stringify(data);
    return Promise.resolve({});
  }),
  getObject: jest.fn().mockImplementation((key: string) => {
    const data = mockData[key];
    if (!data) {
      return Promise.resolve([]); // Return empty array for non-existent files
    }
    return Promise.resolve(JSON.parse(data)); // Parse the data before returning
  }),
  deleteObject: jest.fn().mockImplementation((key: string) => {
    delete mockData[key];
    return Promise.resolve({});
  }),
  listObjects: jest.fn().mockImplementation(() => {
    const keys = Object.keys(mockData).map(key => ({ Key: key }));
    return Promise.resolve({
      Contents: keys,
      IsTruncated: false
    });
  }),
  getObjectMetadata: jest.fn().mockImplementation((key: string) => {
    const data = mockData[key];
    if (!data) {
      return Promise.reject(new Error('NoSuchKey'));
    }
    return Promise.resolve({});
  })
};

jest.mock('../s3Client', () => ({
  __esModule: true,
  S3Client: jest.fn().mockImplementation(() => mockS3Client)
}));

describe('S3CoreDB', () => {
  let db: S3CoreDB;
  let testDoc: DataItem;

  beforeEach(() => {
    // Clear mock data between tests
    Object.keys(mockData).forEach(key => delete mockData[key]);
    
    // Initialize DB with security context
    db = new S3CoreDB(
      'test-key',
      'test-secret',
      'test-bucket',
      '',
      'private',
      undefined,
      { userId: 'test-user', roles: ['admin'] }
    );

    // Create fresh test document for each test
    testDoc = {
      _id: '', // ID will be generated by insert
      name: 'Test Document',
      _version: 1,
      _lastModified: '2025-01-16T12:20:08-05:00'
    };
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('insert', () => {
    it('should insert a new document', async () => {
      const result = await db.insert('users', testDoc);
      expect(result).toBeDefined();
      expect(result).toBe(testDoc._id);
    });
  });

  describe('get', () => {
    it('should retrieve a document', async () => {
      const id = await db.insert('users', testDoc);
      const result = await db.get('users', id);
      expect(result).toBeDefined();
      const doc = result as DataItem;
      expect(doc._id).toBe(id);
    });

    it('should handle security context', async () => {
      const securityContext: SecurityContext = {
        userId: 'user1',
        roles: ['reader']
      };

      const id = await db.insert('users', testDoc);
      db.setSecurityContext(securityContext);
      const result = await db.get('users', id);
      expect(result).toBeDefined();
      const doc = result as DataItem;
      expect(doc._id).toBe(id);
    });
  });

  describe('update', () => {
    it('should update an existing document', async () => {
      const id = await db.insert('users', testDoc);
      const updateDoc = {
        ...testDoc,
        _id: id,
        name: 'Updated Name'
      };

      const result = await db.update('users', updateDoc, id);
      expect(result).toBeDefined();
      expect(result).toBe(id);

      const updated = await db.get('users', id);
      expect(updated).toBeDefined();
      const doc = updated as DataItem;
      expect(doc.name).toBe('Updated Name');
    });
  });

  describe('delete', () => {
    it('should delete a document', async () => {
      const id = await db.insert('users', testDoc);
      const result = await db.delete('users', id);
      expect(result).toBeDefined();
      expect(result).toBe(id);

      const deleted = await db.get('users', id);
      expect(deleted).toBeUndefined();
    });
  });

  describe('get_all', () => {
    it('should retrieve all documents', async () => {
      const id = await db.insert('users', testDoc);
      const results = await db.get_all('users');
      expect(Array.isArray(results)).toBe(true);
      expect(results.length).toBe(1);
      expect(results[0]._id).toBe(id);
    });

    it('should return empty array for empty bucket', async () => {
      const results = await db.get_all('users');
      expect(Array.isArray(results)).toBe(true);
      expect(results.length).toBe(0);
    });
  });
});
